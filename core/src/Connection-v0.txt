import axios, { AxiosRequestConfig } from "axios";
import { ClientConnector } from "./Connector";
import { MorphError } from "./Error";
import { MorphClient } from "./Morph";
import { Resource } from "./Resource";
import type {
  ConnectionCreateParams,
  ConnectionAuthorizeData,
  ConnectionUpdateParams,
  ConnectionData,
  ConnectionIds,
  EitherOr,
  Awaitable,
  EitherDataOrError,
  AuthorizeParams,
  Adapter,
  Connector,
  ConnectorData,
  AdapterConnection,
  ConnectionAuthorizationData,
} from "./types";
import { SessionCreateParams, SessionData } from "./types/session";
import {
  generateAuthorizationUrl,
  getAuthorizationHeader,
  oautCallback,
} from "./utils/oauth";
import { decryptJson } from "./utils/encryption";

function validateAuthorizationSettings(
  connector: ConnectorData<string>,
  settings: Record<string, string>
): EitherOr<[{ settings: Record<string, string> }, { error: MorphError }]> {
  const finalSettings = { ...settings };
  const missingSettings: string[] = [];

  for (const setting of connector.authorization.settings) {
    if (!finalSettings[setting.key]) {
      if (setting.default !== undefined) {
        finalSettings[setting.key] = setting.default;
      } else if (setting.required) {
        missingSettings.push(setting.key);
      }
    }
  }

  if (missingSettings.length > 0) {
    return {
      error: new MorphError({
        code: "MORPH_CONNECTION_MISSING_REQUIRED_AUTHORIZATION_SETTINGS",
        message: `Missing required authorization settings: ${missingSettings.join(
          ", "
        )}`,
      }),
    };
  }

  return { settings: finalSettings };
}

function connectionAdapterToConnectionData(
  adapterConnection: AdapterConnection
): ConnectionData {
  return {
    object: "connection",
    connectorId: adapterConnection.connectorId,
    ownerId: adapterConnection.ownerId,
    status: adapterConnection.status,
    operations: adapterConnection.operations,
    authorization: adapterConnection.authorizationData
      ? JSON.parse(adapterConnection.authorizationData)
      : {},
  };
}

export class ConnectionClient<
  A extends Adapter,
  C extends Connector<I>[],
  I extends string
> {
  private morph: MorphClient<A, C, I>;
  private connectorId: I;
  private ownerId: string;

  constructor(morph: MorphClient<A, C, I>, params: ConnectionIds<I>) {
    this.morph = morph;
    this.connectorId = params.connectorId;
    this.ownerId = params.ownerId;
  }

  async update(
    params: ConnectionUpdateParams
  ): Promise<EitherDataOrError<ConnectionData>> {
    const { data: currentConnection, error: retrieveError } =
      await this.retrieve();
    if (retrieveError) return { error: retrieveError };

    const { data: connectorData, error: connectorError } = await this.morph
      .connector()
      .retrieve(this.connectorId);
    if (connectorError) return { error: connectorError };

    let updatedAuthorization = currentConnection.authorization;
    let updatedOperations = currentConnection.operations;

    if (params.authorization) {
      if (params.authorization.settings) {
        const { settings: verifiedSettings, error } =
          validateAuthorizationSettings(
            connectorData,
            params.authorization.settings
          );
        if (error) return { error };
        updatedAuthorization.settings = {
          ...updatedAuthorization.settings,
          ...verifiedSettings,
        };
      }
      if (params.authorization.scopes) {
        updatedAuthorization.scopes = params.authorization.scopes;
      }
    }

    if (params.operations) {
      updatedOperations = params.operations;
    }

    try {
      const updatedConnectionAdapter =
        await this.morph.database.adapter.updateConnection(
          {
            connectorId: this.connectorId,
            ownerId: this.ownerId,
          },
          {
            operations: updatedOperations,
            authorizationData: JSON.stringify(updatedAuthorization),
          }
        );

      return {
        data: connectionAdapterToConnectionData(updatedConnectionAdapter),
      };
    } catch (e) {
      return {
        error: new MorphError({
          code: "MORPH_CONNECTION_UPDATE_FAILED",
          message: `Failed to update connection: ${JSON.stringify(e)}`,
        }),
      };
    }
  }

  async retrieve(): Promise<EitherDataOrError<ConnectionData>> {
    try {
      const connectionAdapter =
        await this.morph.database.adapter.retrieveConnection({
          connectorId: this.connectorId,
          ownerId: this.ownerId,
        });

      if (!connectionAdapter)
        return {
          error: new MorphError({
            code: "MOPH_CONNECTION_UNKNOWN",
            message: `Connection with connectorId '${this.connectorId}' and ownerId '${this.ownerId}' couldn't be found.`,
          }),
        };
      return { data: connectionAdapterToConnectionData(connectionAdapter) };
    } catch (e) {
      return {
        error: new MorphError({
          code: "MORPH_CONNECTION_RETRIEVE_FAILED",
          message: `Details : ${JSON.stringify(e)}`,
        }),
      };
    }
  }

  async createOrUpdate(
    params?: ConnectionUpdateParams
  ): Promise<EitherDataOrError<ConnectionData>> {
    // First, try to retrieve the existing connection
    const { data: existingConnection, error: retrieveError } =
      await this.retrieve();

    if (retrieveError) {
      // If the connection doesn't exist, create a new one
      if (retrieveError.code === "MOPH_CONNECTION_UNKNOWN") {
        return this.morph.connection().create({
          connectorId: this.connectorId,
          ownerId: this.ownerId,
          ...params,
        });
      }
      // If there's a different error, return it
      return { error: retrieveError };
    }

    // If the connection exists, update it
    return this.update(params as ConnectionUpdateParams);
  }

  async delete(): Promise<void> {
    await this.morph.database.adapter.deleteConnection({
      connectorId: this.connectorId,
      ownerId: this.ownerId,
    });
  }

  async authorize(params?: {
    redirectUrl?: string;
  }): Promise<EitherDataOrError<ConnectionAuthorizeData>> {
    const redirectUrl = params?.redirectUrl;

    const { data: connectorData, error: connectorError } = await this.morph
      .connector()
      .retrieve(this.connectorId);
    if (connectorError) return { error: connectorError };

    if (connectorData.authorization.type !== "oauth2") {
      return {
        error: new MorphError({
          code: "MORPH_NOT_SUPPORTED",
          message: "Only 'ouath2' type authorization supported.",
        }),
      };
    }

    const { data: connectionData, error: connectionError } =
      await this.retrieve();

    if (connectionError) return { error: connectionError };

    const authorizationUrl = generateAuthorizationUrl({
      connector: connectorData,
      ownerId: this.ownerId,
      scopes: connectionData.authorization.scopes,
      redirectUrl,
    });

    const connectionAuthorizationData: ConnectionAuthorizeData = {
      object: "connection.authorize",
      connectorId: this.connectorId,
      ownerId: this.ownerId,
      status: "awaiting_authorization", // TODO: not if connection already authorize. Need to connection.verify();
      authorizationUrl,
    };

    return { data: connectionAuthorizationData };
  }

  resource(resourceType: string): Resource {
    // Implementation
    return new Resource(resourceType);
  }

  async proxy(params: {
    path: string;
    method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
    data?: any;
    headers: Record<string, string>;
  }): Promise<EitherDataOrError<any>> {
    try {
      const { path, method, data, headers = {} } = params;
      const { data: connectorData, error: connectorError } = await this.morph
        .connector()
        .retrieve(this.connectorId);
      if (connectorError) return { error: connectorError };

      const baseUrl = connectorData.proxy.baseUrl;
      if (!baseUrl) {
        return {
          error: new MorphError({
            code: "MORPH_CONNECTOR_INVALID_CONFIG",
            message: "Proxy API base URL is not defined for this connector.",
          }),
        };
      }

      const url = new URL(path, baseUrl).toString();

      // Get the authorization header
      const authHeader = await getAuthorizationHeader(
        this.morph,
        this.connectorId,
        this.ownerId
      );

      // Prepare the request config
      const requestConfig: AxiosRequestConfig = {
        method,
        url,
        headers: {
          ...headers,
          ...(authHeader && { Authorization: authHeader }),
        },
        data,
      };

      const response = await axios(requestConfig);
      return { data: response.data };
    } catch (e) {
      if (axios.isAxiosError(e)) {
        return {
          error: new MorphError({
            code: "MORPH_PROXY_REQUEST_FAILED",
            message: `Proxy request failed: ${e}`,
          }),
        };
      }
      return {
        error: new MorphError({
          code: "MORPH_PROXY_REQUEST_FAILED",
          message: `Proxy request failed: ${
            e instanceof Error ? e.message : String(e)
          }`,
        }),
      };
    }
  }
}

export class ConnectionSessionClient<
  A extends Adapter,
  C extends Connector<I>[],
  I extends string
> {
  private morph: MorphClient<A, C, I>;
  private sessionToken: string;

  constructor(morph: MorphClient<A, C, I>, params: { sessionToken: string }) {
    this.morph = morph;
    this.sessionToken = params.sessionToken;
  }

  update(
    ...params: FunctionParams<"update", A, C, I>
  ): FunctionReturn<"update", A, C, I> {
    return this.loadConnectionFunction("update", params);
  }

  retrieve(
    ...params: FunctionParams<"retrieve", A, C, I>
  ): FunctionReturn<"retrieve", A, C, I> {
    return this.loadConnectionFunction("retrieve", params);
  }

  delete(
    ...params: FunctionParams<"delete", A, C, I>
  ): FunctionReturn<"delete", A, C, I> {
    return this.loadConnectionFunction("delete", params);
  }

  authorize(
    ...params: FunctionParams<"authorize", A, C, I>
  ): FunctionReturn<"authorize", A, C, I> {
    return this.loadConnectionFunction("authorize", params);
  }

  resource(
    ...params: FunctionParams<"resource", A, C, I>
  ): FunctionReturn<"resource", A, C, I> {
    return this.loadConnectionFunction("resource", params);
  }

  proxy(
    ...params: FunctionParams<"proxy", A, C, I>
  ): FunctionReturn<"proxy", A, C, I> {
    return this.loadConnectionFunction("proxy", params);
  }

  /*async authorize(params?: {
    redirectUrl?: string;
  }): Promise<EitherDataOrError<ConnectionAuthorizeData>> {
    const { connection, error: connectionError } = await this.verifySession();
    if (connectionError) return { error: connectionError };
    const { data, error } = await connection.authorize(params);
    if (error) return { error };
    return { data };
  }*/

  private async verifySession(): Promise<
    EitherOr<[{ connection: ConnectionClient<A, C, I> }, { error: MorphError }]>
  > {
    const { data, error } = await this.morph
      .session()
      .verify(this.sessionToken);
    if (error) return { error };
    const connection = this.morph.connection({
      connectorId: data.connection.connectorId as C[number]["id"],
      ownerId: data.connection.ownerId,
    });
    return { connection };
  }

  private async loadConnectionFunction<
    F extends keyof ConnectionClient<A, C, I>
  >(
    method: F & (ConnectionClient<A, C, I>[F] extends Function ? F : never),
    params: Parameters<ConnectionClient<A, C, I>[F]>
  ): Promise<
    | { error: MorphError; data?: undefined }
    | (ReturnType<ConnectionClient<A, C, I>[F]> extends Promise<infer R>
        ? R extends { error: MorphError } | { data: any }
          ? R
          : never
        : never)
  > {
    const { connection, error: connectionError } = await this.verifySession();
    if (connectionError) return { error: connectionError };

    try {
      const result = await (connection[method] as Function)(...params);
      return result as any;
    } catch (e) {
      return {
        error: new MorphError({
          code: "MORPH_CONNECTION_METHOD_FAILED",
          message: `Error executing ${String(method)}: ${
            e instanceof Error ? e.message : String(e)
          }`,
        }),
      };
    }
  }
}

type FunctionParams<
  F extends keyof ConnectionClient<A, C, I>,
  A extends Adapter,
  C extends Connector<I>[],
  I extends string
> = Parameters<ConnectionClient<A, C, I>[F]>;

type FunctionReturn<
  F extends keyof ConnectionClient<A, C, I>,
  A extends Adapter,
  C extends Connector<I>[],
  I extends string
> = Promise<
  | { error: MorphError; data?: undefined }
  | (ReturnType<ConnectionClient<A, C, I>[F]> extends Promise<infer R>
      ? R extends { error: MorphError } | { data: any }
        ? R
        : never
      : never)
>;

export class AllConnectionsClient<
  A extends Adapter,
  C extends Connector<I>[],
  I extends string
> {
  private morph: MorphClient<A, C, I>;

  constructor(morph: MorphClient<A, C, I>) {
    this.morph = morph;
  }

  async create(
    params: ConnectionCreateParams<I>
  ): Promise<EitherDataOrError<ConnectionData>> {
    const { connectorId, ownerId } = params;
    const { data: connectorData, error } = await this.morph
      .connector()
      .retrieve(connectorId);

    if (error) return { error };

    let finalAuthorization: ConnectionData["authorization"] = {
      scopes: [],
      settings: {},
    };
    let finalOperations: ConnectionData["operations"] = [];
    if (params) {
      const { authorization, operations } = params;
      finalAuthorization.scopes = authorization?.scopes || [];
      if (authorization?.settings) {
        const { settings: verifiedSettings, error } =
          validateAuthorizationSettings(connectorData, authorization.settings);

        if (error) return { error };

        finalAuthorization.settings = verifiedSettings;
      }

      if (operations) {
        finalOperations = operations;
      }
    }

    try {
      const connectionAdapter =
        await this.morph.database.adapter.createConnection({
          connectorId: connectorId,
          ownerId: ownerId,
          status: "pending",
          operations: finalOperations,
          authorizationType: connectorData.authorization.type,
          authorizationData: JSON.stringify(finalAuthorization),
        });

      return { data: connectionAdapterToConnectionData(connectionAdapter) };
    } catch (e) {
      return {
        error: new MorphError({
          code: "MORPH_CONNECTION_CREATION_FAILED",
          message: `Details : ${JSON.stringify(e)}`,
        }),
      };
    }
  }

  list(params: {}): Awaitable<EitherDataOrError<ConnectionData>> {
    // Implementation

    return {
      error: new MorphError({
        code: "NOT_IMPLEMENTED",
        message: "Methode not yet implemented",
      }),
    };
  }

  callback(
    params: AuthorizeParams
  ): Awaitable<
    EitherOr<
      [
        { connection: ConnectionData; redirectUrl: string },
        { error: MorphError }
      ]
    >
  > {
    return oautCallback(this.morph, params);
  }
}
