import { ResourceRef, Resource } from "../resources";
import { EntityData } from "../models";

/*type PathToRemoteValue<RemoteDataType> = RemoteDataType extends object ? 
    { [K in keyof RemoteDataType]: K extends string | number ? 
        `${K}` | (RemoteDataType[K] extends (infer U)[] ? 
            `${K}` | `${K}.0` | `${K}.0.${PathToRemoteValue<U>}` : 
            (RemoteDataType[K] extends object ? `${K}.${PathToRemoteValue<RemoteDataType[K]>}` : never)
        ) : never 
    }[keyof RemoteDataType] 
    : '';
*/

type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type FlattenObjectExtras =
  | undefined
  | null
  | boolean
  | string
  | number
  | bigint
  | Function
  | Date;

type FlattenObjectPaths<T> = T extends FlattenObjectExtras
  ? never
  :
      | {
          [K in keyof T]-?: K extends string | number
            ? T[K] extends Array<infer I>
              ? `${K}` | `${K}.0` | `${K}.0.${FlattenObjectPaths<I>}`
              :
                  | `${K}`
                  | (FlattenObjectPaths<T[K]> extends infer D
                      ? `${K}.${D & string}`
                      : never)
            : never;
        }[keyof T]
      | "*";

type ValueOf<T, P extends string> = P extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? ValueOf<T[K], Rest>
    : T extends Array<infer I>
    ? ValueOf<I, Rest>
    : never
  : P extends keyof T
  ? T[P]
  : P extends "*"
  ? DeepPartial<T>
  : T extends Array<infer I>
  ? I
  : never;

type ConstructFlattenedType<T, P extends string = FlattenObjectPaths<T>> = {
  [Path in P]: ValueOf<T, Path>;
};

type ReadValueFunction<RD, EDV, PV> = (path_value: PV, remote_data: RD) => EDV;
type WriteValueFunction<ED, EDV, PV> = (
  entity_data_value: EDV,
  entity_data: ED
) => PV;

type AttributeConfig<
  RD,
  EDV,
  ED extends EntityData,
  FLDS extends ReadonlyArray<string>,
  FLTR extends string,
  PATH extends keyof ConstructFlattenedType<RD>,
  PV extends ConstructFlattenedType<RD>[PATH]
> = {
  readonly path: PATH;
  readonly read?: ReadValueFunction<RD, EDV, PV>;
  readonly write?: WriteValueFunction<ED, EDV, PV>;
  readonly field?: string;
  readonly fields?: FLDS;
  readonly filter?: FLTR;
};

export class Attribute<
  RD,
  EDV,
  ED extends EntityData,
  FLDS extends ReadonlyArray<string>,
  FLTR extends string,
  P extends keyof ConstructFlattenedType<RD>,
  PV extends ConstructFlattenedType<RD>[P]
> {
  readonly path: P;
  readonly read?: ReadValueFunction<RD, EDV, PV>;
  readonly write?: WriteValueFunction<ED, EDV, PV>;
  readonly field?: string;
  readonly fields?: FLDS;
  readonly filter?: FLTR;

  constructor(private config: AttributeConfig<RD, EDV, ED, FLDS, FLTR, P, PV>) {
    this.path = config.path;
    this.read = config.read;
    this.write = config.write;
    this.field = config.field;
    this.fields = (config.fields || ([] as ReadonlyArray<string>)) as FLDS;
    this.filter = config.filter;
  }

  buildFilter<K extends FLTR>(value: string): { [P in K]: string } {
    if (this.filter) {
      return { [this.filter]: value } as { [P in K]: string };
    }
    return {} as { [P in K]: string };
  }
}

type IdAttributeConfig<
  RD,
  EDV,
  ED extends EntityData,
  FLDS extends ReadonlyArray<string>,
  PATH extends keyof ConstructFlattenedType<RD>,
  PV extends ConstructFlattenedType<RD>[PATH]
> = {
  readonly path: PATH;
  readonly read?: ReadValueFunction<RD, EDV, PV>;
  readonly write?: WriteValueFunction<ED, EDV, PV>;
  readonly field?: string;
  readonly fields?: FLDS;
};

export class IdAttribute<
  RD,
  EDV,
  ED extends EntityData,
  FLDS extends ReadonlyArray<string>,
  P extends keyof ConstructFlattenedType<RD>,
  PV extends ConstructFlattenedType<RD>[P]
> {
  readonly path: P;
  readonly read?: ReadValueFunction<RD, EDV, PV>;
  readonly write?: WriteValueFunction<ED, EDV, PV>;
  readonly field?: string;
  readonly fields?: FLDS;

  constructor(private config: IdAttributeConfig<RD, EDV, ED, FLDS, P, PV>) {
    this.path = config.path;
    this.read = config.read;
    this.write = config.write;
    this.field = config.field;
    this.fields = (config.fields || ([] as ReadonlyArray<string>)) as FLDS;
  }
}

type TimestampAttributeConfig<
  RD,
  EDV,
  ED extends EntityData,
  FLDS extends ReadonlyArray<string>,
  PATH extends keyof ConstructFlattenedType<RD>,
  PV extends ConstructFlattenedType<RD>[PATH]
> = {
  readonly path: PATH;
  readonly read?: ReadValueFunction<RD, EDV, PV>;
  readonly field?: string;
  readonly fields?: FLDS;
  readonly sort?: {
    asc?: string;
    desc?: string;
  };
};

export class TimestampAttribute<
  RD,
  EDV,
  ED extends EntityData,
  FLDS extends ReadonlyArray<string>,
  P extends keyof ConstructFlattenedType<RD>,
  PV extends ConstructFlattenedType<RD>[P]
> {
  readonly path: P;
  readonly read?: ReadValueFunction<RD, EDV, PV>;
  readonly field?: string;
  readonly fields?: FLDS;
  readonly sort?: {
    asc?: string;
    desc?: string;
  };

  constructor(
    private config: TimestampAttributeConfig<RD, EDV, ED, FLDS, P, PV>
  ) {
    this.path = config.path;
    this.read = config.read;
    this.field = config.field;
    this.fields = (config.fields || ([] as ReadonlyArray<string>)) as FLDS;
    this.sort = config.sort;
  }
}

type ResourceConfig<ED extends EntityData, RD> = {
  id: {
    [P in keyof ConstructFlattenedType<RD>]: IdAttributeConfig<
      RD,
      string,
      ED,
      ReadonlyArray<string>,
      P,
      ConstructFlattenedType<RD>[P]
    >;
  }[keyof ConstructFlattenedType<RD>];

  parents?: {
    [P in keyof ConstructFlattenedType<RD>]: IdAttributeConfig<
      RD,
      string,
      ED,
      ReadonlyArray<string>,
      P,
      ConstructFlattenedType<RD>[P]
    >;
  }[keyof ConstructFlattenedType<RD>];

  data?: {
    [K in keyof ED]: ED[K] extends ResourceRef<infer RefED>
      ? ResourceRefConfig<RefED, RD>
      : {
          [P in keyof ConstructFlattenedType<RD>]: AttributeConfig<
            RD,
            NonNullable<ED[K]>,
            ED,
            ReadonlyArray<NonNullable<ED[K]["fields"]>[number]>,
            NonNullable<ED[K]["filter_key"]>,
            P,
            P extends keyof ConstructFlattenedType<RD>
              ? ConstructFlattenedType<RD>[P]
              : never
          >;
        }[keyof ConstructFlattenedType<RD>];
  };

  created_at?: {
    [P in keyof ConstructFlattenedType<RD>]: TimestampAttributeConfig<
      RD,
      Date,
      ED,
      ReadonlyArray<string>,
      P,
      ConstructFlattenedType<RD>[P]
    >;
  }[keyof ConstructFlattenedType<RD>];

  updated_at?: {
    [P in keyof ConstructFlattenedType<RD>]: TimestampAttributeConfig<
      RD,
      Date,
      ED,
      ReadonlyArray<string>,
      P,
      ConstructFlattenedType<RD>[P]
    >;
  }[keyof ConstructFlattenedType<RD>];
};

type ResourceSchema<
  ED extends EntityData,
  RD,
  RC extends ResourceConfig<ED, RD>
> = {
  id: IdAttribute<
    RD,
    string,
    ED,
    ReadonlyArray<string>,
    keyof ConstructFlattenedType<RD>,
    ConstructFlattenedType<RD>[keyof ConstructFlattenedType<RD>]
  >;
  parents?: {
    [K in keyof RC["parents"]]: IdAttribute<
      RD,
      string,
      ED,
      ReadonlyArray<string>,
      keyof ConstructFlattenedType<RD>,
      ConstructFlattenedType<RD>[keyof ConstructFlattenedType<RD>]
    >;
  };
  data: {
    [K in keyof RC["data"]]: RC["data"][K] extends ResourceRefConfig<
      infer RefED,
      RD
    >
      ? ResourceRefSchema<RC["data"][K], RefED, RD>
      : RC["data"][K] extends AttributeConfig<
          infer _RD,
          infer _EDV,
          infer _ED,
          infer _T,
          infer _F,
          infer _P,
          infer _PV
        >
      ? Attribute<_RD, _EDV, _ED, _T, _F, _P, _PV>
      : never;
  };
  created_at: TimestampAttribute<
    RD,
    Date,
    ED,
    ReadonlyArray<string>,
    keyof ConstructFlattenedType<RD>,
    ConstructFlattenedType<RD>[keyof ConstructFlattenedType<RD>]
  >;
  updated_at: TimestampAttribute<
    RD,
    Date,
    ED,
    ReadonlyArray<string>,
    keyof ConstructFlattenedType<RD>,
    ConstructFlattenedType<RD>[keyof ConstructFlattenedType<RD>]
  >;
};

type ResourceRefConfig<ED extends EntityData, RD> = {
  id: IdAttributeConfig<
    RD,
    string,
    ED,
    ReadonlyArray<string>,
    keyof ConstructFlattenedType<RD>,
    ConstructFlattenedType<RD>[keyof ConstructFlattenedType<RD>]
  >;
  parents?: {
    [key: string]: IdAttributeConfig<
      RD,
      string,
      ED,
      ReadonlyArray<string>,
      keyof ConstructFlattenedType<RD>,
      ConstructFlattenedType<RD>[keyof ConstructFlattenedType<RD>]
    >;
  };
};
type ResourceRefSchema<
  RRC extends ResourceRefConfig<ED, RD>,
  ED extends EntityData,
  RD
> = {
  id: IdAttribute<
    RD,
    string,
    ED,
    ReadonlyArray<string>,
    keyof ConstructFlattenedType<RD>,
    ConstructFlattenedType<RD>[keyof ConstructFlattenedType<RD>]
  >;
  parents?: {
    [K in keyof RRC["parents"]]: IdAttribute<
      RD,
      string,
      ED,
      ReadonlyArray<string>,
      keyof ConstructFlattenedType<RD>,
      ConstructFlattenedType<RD>[keyof ConstructFlattenedType<RD>]
    >;
  };
};

export class Schema<
  ED extends EntityData,
  RD,
  RC extends ResourceConfig<ED, RD> = ResourceConfig<ED, RD>
> {
  entity_data?: ED;
  remote_data?: RD;
  schema?: RC;

  private createSchema<
    ED extends EntityData,
    RD,
    RC extends ResourceConfig<ED, RD>
  >(schema: RC, entity_data?: ED, remote_data?: RD) {
    return {
      entity_data: entity_data,
      remote_data: remote_data,
      schema: schema,
    };
  }

  getSchema() {
    return this.schema;
  }

  getAllFields(): readonly string[] {
    if (!this.schema) {
      return [] as const;
    }

    const fields: string[] = [];
    for (const key in this.schema.data) {
      const attributeConfig = this.schema.data[key];
      if ("fields" in attributeConfig) {
        fields.push(...(attributeConfig.fields as readonly string[]));
      }
    }
    return fields;
  }

  fromRemoteDataToResourceEntityData(remote_data: RD): Resource<ED> {
    if (!this.schema) {
      throw new Error("Schema is not defined");
    }

    const entityData: Partial<ED> = {};
    let id: string | undefined;

    // Process ID
    if (this.schema.id && typeof this.schema.id.read === "function") {
      const idValue = this.getNestedValue(remote_data, this.schema.id.path);
      id = this.schema.id.read(idValue, remote_data);
    }

    // Process data attributes
    for (const key in this.schema.data) {
      const attributeConfig = this.schema.data[key];
      if (
        "read" in attributeConfig &&
        typeof attributeConfig.read === "function"
      ) {
        const pathValue = this.getNestedValue(
          remote_data,
          attributeConfig.path
        );
        const value = attributeConfig.read(pathValue, remote_data);
        if (value !== undefined) {
          (entityData as any)[key] = value;
        }
      }
    }

    // Process timestamps
    let created_at: string | undefined;
    let updated_at: string | undefined;

    if (
      this.schema.created_at &&
      typeof this.schema.created_at.read === "function"
    ) {
      const createdAtValue = this.getNestedValue(
        remote_data,
        this.schema.created_at.path
      );
      const createdAtDate = this.schema.created_at.read(
        createdAtValue,
        remote_data
      );
      created_at = createdAtDate ? createdAtDate.toISOString() : undefined;
    }

    if (
      this.schema.updated_at &&
      typeof this.schema.updated_at.read === "function"
    ) {
      const updatedAtValue = this.getNestedValue(
        remote_data,
        this.schema.updated_at.path
      );
      const updatedAtDate = this.schema.updated_at.read(
        updatedAtValue,
        remote_data
      );
      updated_at = updatedAtDate ? updatedAtDate.toISOString() : undefined;
    }

    return {
      id: id || "",
      data: entityData as ED,
      remote_data,
      created_at,
      updated_at,
    };
  }

  private getNestedValue(obj: any, path: string): any {
    return path
      .split(".")
      .reduce((current, key) => current && current[key], obj);
  }

  toTypeScriptSchemaJSON(): object {
    if (!this.schema) {
      throw new Error("Schema is not defined");
    }
    console.log("start generation");
    const properties: Record<string, any> = {};
    const required: string[] = [];

    const fields: string[] = [];
    for (const key in this.schema.data) {
      const attributeConfig = this.schema.data[key];
      console.log(attributeConfig);
      if ("read" in attributeConfig) {
        properties[key] = {
          type: "number", // Assuming all fields are strings for simplicity. Adjust as needed.
        };
      }

      if (
        "fields" in attributeConfig &&
        attributeConfig.fields &&
        attributeConfig.fields.length > 0
      ) {
        fields.push(...attributeConfig.fields);
      }

      if ("field" in attributeConfig && attributeConfig.field) {
        fields.push(attributeConfig.field);
      }
    }

    return {
      $schema: "http://json-schema.org/draft-07/schema#",
      title: "GeneratedSchema",
      type: "object",
      properties: properties,
      required: required,
    };
  }

  constructor(entity_data?: ED, remote_data?: RD, schema?: RC) {
    this.entity_data = entity_data;
    this.remote_data = remote_data;
    this.schema = schema;
  }

  returnSelf<ED extends EntityData, RD, RC extends ResourceConfig<ED, RD>>(
    schema: RC,
    entity_data: ED,
    remote_data: RD
  ) {
    return new Schema<ED, RD, RC>(entity_data, remote_data, schema);
  }

  returnSelfLess<ED extends EntityData, RD, RC extends ResourceConfig<ED, RD>>(
    schema: RC
  ) {
    return new Schema<ED, RD, RC>(undefined, undefined, schema);
  }

  map = <RC extends ResourceConfig<ED, RD>>(schema: RC) =>
    this.returnSelfLess<ED, RD, RC>(schema);
  /* this.remote_data && this.entity_data
      ? this.returnSelf<ED, RD, RC>(schema, this.entity_data, this.remote_data)
      : this.createSchema<ED, RD, RC>(
          schema,
          this.entity_data,
          this.remote_data
        );*/
}

/*

type Contact = {
    full_name: string;
    first_name: string;
    last_name: string;
    email: string;
}*/

type HubSpotContact = {
  firstname?: string;
  lastname: string;
};
//import { Contact } from '../models/contact';

const b = new Schema<PersonModel, HubSpotDeal>().map({
  id: {
    field: "id",
    path: "id",
  },
  data: {
    description: {
      path: "properties.Email",
      read: (path_value) => {
        return path_value.map((v) => v.value).join(", ");
      },
      write: (entity_data_value) => {
        return entity_data_value?.split(", ").map((v) => ({ value: v })) || [];
      },
      field: "Email",
      filter: "Email",
    },
    email: {
      path: "properties.Email",
      read: (path_value) => path_value[0]?.value,
      write: (entity_data_value, _) => [{ value: entity_data_value }],
    },
    tags: {
      path: "properties.Tags",
      read: (path_value) => path_value.map((v) => ({ name: v })),
      write: (entity_data_value, _) => entity_data_value.map((v) => v.name),
    },
    first_name: {
      path: "properties.Fullname",
      read: (remote_value, _) => remote_value.split(" ")[0],
      write: (entity_data_value, entity_data) =>
        `${entity_data_value} ${entity_data.last_name}`,
    },
    last_name: {
      path: "properties.Fullname",
      read: (remote_value, _) => remote_value.split(" ")[1],
      write: (entity_data_value, entity_data) =>
        `${entity_data.first_name} ${entity_data_value}`,
    },
    full_name: {
      path: "*",
      read: (remote_value, _) =>
        `${remote_value.properties?.FirstName} ${remote_value.properties?.LastName}`,
      write: (entity_data_value, _) => ({
        properties: {
          FirstName: entity_data_value?.split(" ")[0],
          LastName: entity_data_value?.split(" ")[1],
        },
      }),
    },
  },
  created_at: {
    path: "createdAt",
    read: (remote_value) => new Date(remote_value),
    sort: {
      asc: "createdate",
      desc: "-createdate",
    },
  },
  updated_at: {
    path: "updatedAt",
    read: (remote_value) => new Date(remote_value),
    sort: {
      asc: "lastmodifieddate",
      desc: "-lastmodifieddate",
    },
  },
});

function test(remote_data: typeof b.remote_data) {
  return remote_data?.properties.Fullname;
}

class PersonModel implements EntityData {
  full_name?: string;
  first_name?: string;
  last_name?: string;
  description?: string;
  deep_person?: boolean; //ResourceRef<PersonModel>
  role?: string;
  email?: string;
  tags?: { name: string }[];
}

type HubSpotDeal = typeof hs_deal;

const hs_deal = {
  id: "17590686638",
  properties: {
    FirstName: "John",
    LastName: "Doe",
    Fullname: "John Doe",
    Role: "PM",
    Email: [{ value: "j.deo@gmail.com" }],
    Tags: ["tag1", "tag2"],
  },
  createdAt: "2024-02-17T11:02:36.515Z",
  updatedAt: "2024-05-16T17:04:44.815Z",
};
