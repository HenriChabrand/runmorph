import { Operation, Metadata, Error, ErrorType } from './operation';
import { Model, Raw } from '../models';
import { Resource } from '../resources';
import { Runtime } from '../runtime';
import { Schema, ExtractSchemaModel } from './schema';

export const Sort = {
    CREATED_AT_ASC : 'created_at',
    CREATED_AT_DESC : '-created_at',
    UPDATED_AT_ASC : 'updated_at',
    UPDATED_AT_DESC : '-updated_at'
} as const;


type Input<S extends Schema<Model,any>> = { 
    page_size: number;
    cursor: any | null;
    sort: typeof Sort[keyof typeof Sort] | null;
    //filter: { [K in keyof Raw<M>]?: Raw<M>[K] } | null;
    remote_fields:  string[];
};

type Output<S extends Schema<Model,any>> = { 
    object?: string;
    data: Resource<ExtractSchemaModel<S>>[]
    next: object | null;
};
  
export class List<S extends Schema<Model,any>> extends Operation<S> {
    private handler: (runtime:Runtime, data:Input<S> ) =>  Promise<Output<S>>;

    //static Sort = Sort;

    constructor(handler: (runtime:Runtime, data:Input<S>) => Promise<Output<S>>, metadata:Metadata<S>) {
        super({
            id:'list',
            schema: metadata.schema,
            scopes: metadata?.scopes || []
        });     
        this.handler = handler;      
    }

    async run(runtime:Runtime, data: Input<S>): Promise<Output<S>|Error> {
        try {
            const output: Output<S> = await this.handler(runtime, data);
        
            return { 
                object: 'list',
                data:  output.data, 
                next: output.next 
            };
        } catch (error) {
            // If an error is thrown, catch it and return as an Error object
            return error instanceof Error ? error : new Error(ErrorType.UNKNOWN_ERROR, String(error))
        }
    }
}