import { Model, Raw } from '../models';
import { Runtime } from '../runtime';
import { Metadata } from './operation';

type OperationTypes = 'list' | 'retrieve' | 'create' | 'update';

export type ModelFields<M extends Model> = {
    [K in keyof Raw<M>]: {
        remote_fields: string[];
        operations: OperationTypes[];
    }
};

type FieldInfo = {
    remote_keys: string[];
    operations: OperationTypes[];
};

type FieldValueTypes = 'text' | 'textarea' | 'number' | 'date' | 'select' | 'checkbox';
type FieldValueTextFormat = 'password' | 'email' | 'phone_number' | 'date';
type FieldValueNumberFormat = 'int' | 'float' | 'percent' | 'currency';

type RemoteFieldValueOption = {
    label: string;
    value: string | number;
}

export class Field {    
    type: 'model' | 'remote' | 'extra';
    key: string;   
    label: string;
    operations: OperationTypes[];
    value_type: FieldValueTypes;
    value_options?: RemoteFieldValueOption[];
  
    constructor({type, key, label, operations, value_type, value_options }: Field) {
        this.type = type;
        this.key = key;      
        this.label = label;
        this.operations = operations;
        this.value_type = value_type;
    }
}

export class RemoteField {
    label: string;
    operations: OperationTypes[];
    value_type: FieldValueTypes;
    remote_field_key: string;
    read_path?: string[];
    write_path?: string[];
    value_options?: RemoteFieldValueOption[];
  
    constructor({label, operations, value_type, remote_field_key, read_path, write_path, value_options }: RemoteField) {
        this.remote_field_key = remote_field_key;
        this.label = label;        
        this.operations = operations;
        this.value_type = value_type;
        
        if(remote_field_key) {
            this.remote_field_key = remote_field_key;
        }

        if(read_path) {
            this.read_path = read_path;
        }

        if(write_path) {
            this.write_path = write_path;
        }

        if(value_options) {
            this.value_options = value_options;
        }
    }
}

type Output<M extends Model> = RemoteField[];

export class Fields<M extends Model> {
    private metadata: Metadata<M>;

    constructor(private handler: (runtime: Runtime) => Promise<Output<M>>, metadata: Metadata<M>) {
        this.metadata = metadata;
    }
    async run(runtime: Runtime): Promise<Field[]> {
        const model_fields = this.getModelFields();
        const remote_fields = await this.handler(runtime);
        const mapped_remote_fields = remote_fields.map((remote_field) => new Field({
            type: 'remote',
            key: 'remote::' + Buffer.from(`${remote_field.remote_field_key}::${remote_field.read_path?.join('.')}::${remote_field.write_path?.join('.')}::`).toString('base64'),                
            label: remote_field.label,
            operations: remote_field.operations,
            value_type: remote_field.value_type,
            value_options: remote_field.value_options
        }));
        return model_fields.concat(mapped_remote_fields);
    }

    getModelFields(): Field[] {
        const fieldsMetadata = this.metadata.fields || {};

        // Utilisation d'une assertion de type pour fieldInfo dans Object.entries
        const fields: Field[] = Object.entries(fieldsMetadata).map(([fieldName, fieldInfo]) => {
            // Ici, vous dites explicitement Ã  TypeScript que fieldInfo est de type FieldInfo
            const info = fieldInfo as FieldInfo;

            const label = fieldName.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
            const operations = info.operations;
            const value_type = this.determineValueType(fieldName);
            const value_options = this.getValueOptions(fieldName);

            return new Field({
                type: 'model',
                key: fieldName,                
                label,
                operations,
                value_type,
                value_options
            });
        });

        return fields;
    }

    private determineValueType(fieldName: string): FieldValueTypes {
        return 'text'; // Default to text for test
    }

    private getValueOptions(fieldName: string): RemoteFieldValueOption[] | undefined {
        return []; // Default to [] for test
    }
}